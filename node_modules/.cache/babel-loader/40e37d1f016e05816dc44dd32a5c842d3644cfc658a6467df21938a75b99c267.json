{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar isPlainObject = require('is-plain-object');\nvar React = require('react');\nvar prettyPrintObject = require('@base2/pretty-print-object');\nvar reactIs = require('react-is');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar spacer = function (times, tabStop) {\n  if (times === 0) {\n    return '';\n  }\n  return new Array(times * tabStop).fill(' ').join('');\n};\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction safeSortObject(value, seen) {\n  // return non-object value as is\n  if (value === null || _typeof(value) !== 'object') {\n    return value;\n  } // return date, regexp and react element values as is\n\n  if (value instanceof Date || value instanceof RegExp || /*#__PURE__*/React__namespace.isValidElement(value)) {\n    return value;\n  }\n  seen.add(value); // make a copy of array with each item passed through the sorting algorithm\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return safeSortObject(v, seen);\n    });\n  } // make a copy of object with key sorted\n\n  return Object.keys(value).sort().reduce(function (result, key) {\n    if (key === '_owner') {\n      return result;\n    }\n    if (key === 'current' || seen.has(value[key])) {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = '[Circular]';\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = safeSortObject(value[key], seen);\n    }\n    return result;\n  }, {});\n}\nfunction sortObject(value) {\n  return safeSortObject(value, new WeakSet());\n}\n\n/* eslint-disable no-use-before-define */\nvar createStringTreeNode = function createStringTreeNode(value) {\n  return {\n    type: 'string',\n    value: value\n  };\n};\nvar createNumberTreeNode = function createNumberTreeNode(value) {\n  return {\n    type: 'number',\n    value: value\n  };\n};\nvar createReactElementTreeNode = function createReactElementTreeNode(displayName, props, defaultProps, childrens) {\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: defaultProps,\n    childrens: childrens\n  };\n};\nvar createReactFragmentTreeNode = function createReactFragmentTreeNode(key, childrens) {\n  return {\n    type: 'ReactFragment',\n    key: key,\n    childrens: childrens\n  };\n};\nvar supportFragment = Boolean(React.Fragment);\nvar getFunctionTypeName = function getFunctionTypeName(functionType) {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\nvar getWrappedComponentDisplayName = function getWrappedComponentDisplayName(Component) {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === reactIs.Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === reactIs.ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n}; // heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case reactIs.isForwardRef(element):\n    case reactIs.isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case reactIs.isContextConsumer(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Consumer\");\n    case reactIs.isContextProvider(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Provider\");\n    case reactIs.isLazy(element):\n      return 'Lazy';\n    case reactIs.isProfiler(element):\n      return 'Profiler';\n    case reactIs.isStrictMode(element):\n      return 'StrictMode';\n    case reactIs.isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== 'children';\n};\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== '';\n};\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n    displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (! /*#__PURE__*/React__default[\"default\"].isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\".concat(_typeof(element), \"`\"));\n  }\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n  var key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  var childrens = React__default[\"default\"].Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n  if (supportFragment && element.type === React.Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n  return createReactElementTreeNode(displayName, props, defaultProps, childrens);\n};\nfunction noRefCheck() {}\nvar inlineFunction = function inlineFunction(fn) {\n  return fn.toString().split('\\n').map(function (line) {\n    return line.trim();\n  }).join('');\n};\nvar preserveFunctionLineBreak = function preserveFunctionLineBreak(fn) {\n  return fn.toString();\n};\nvar defaultFunctionValue = inlineFunction;\nvar formatFunction = function (fn, options) {\n  var _options$functionValu = options.functionValue,\n    functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu,\n    showFunctions = options.showFunctions;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n  return functionValue(fn);\n};\nvar formatComplexDataStructure = function (value, inline, lvl, options) {\n  var normalizedValue = sortObject(value);\n  var stringifiedValue = prettyPrintObject.prettyPrint(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n      if (currentValue && /*#__PURE__*/React.isValidElement(currentValue)) {\n        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);\n      }\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n      return originalResult;\n    }\n  });\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, ' ').replace(/{ /g, '{').replace(/ }/g, '}').replace(/\\[ /g, '[').replace(/ ]/g, ']');\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n  return stringifiedValue.replace(/\\t/g, spacer(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\".concat(spacer(lvl + 1, options.tabStop), \"$1\"));\n};\nvar escape$1 = function escape(s) {\n  return s.replace(/\"/g, '&quot;');\n};\nvar formatPropValue = function formatPropValue(propValue, inline, lvl, options) {\n  if (typeof propValue === 'number') {\n    return \"{\".concat(String(propValue), \"}\");\n  }\n  if (typeof propValue === 'string') {\n    return \"\\\"\".concat(escape$1(propValue), \"\\\"\");\n  } // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n\n  if (_typeof(propValue) === 'symbol') {\n    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\\((.*)\\)/, '$1');\n    if (!symbolDescription) {\n      return \"{Symbol()}\";\n    }\n    return \"{Symbol('\".concat(symbolDescription, \"')}\");\n  }\n  if (typeof propValue === 'function') {\n    return \"{\".concat(formatFunction(propValue, options), \"}\");\n  }\n  if ( /*#__PURE__*/React.isValidElement(propValue)) {\n    return \"{\".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), \"}\");\n  }\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return \"{new Date(NaN)}\";\n    }\n    return \"{new Date(\\\"\".concat(propValue.toISOString(), \"\\\")}\");\n  }\n  if (isPlainObject.isPlainObject(propValue) || Array.isArray(propValue)) {\n    return \"{\".concat(formatComplexDataStructure(propValue, inline, lvl, options), \"}\");\n  }\n  return \"{\".concat(String(propValue), \"}\");\n};\nvar formatProp = function (name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\"The prop \\\"\".concat(name, \"\\\" has no value and no default: could not be formatted\"));\n  }\n  var usedValue = hasValue ? value : defaultValue;\n  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax,\n    tabStop = options.tabStop;\n  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n  var attributeFormattedInline = ' ';\n  var attributeFormattedMultiline = \"\\n\".concat(spacer(lvl + 1, tabStop));\n  var isMultilineAttribute = formattedPropValue.includes('\\n');\n  if (useBooleanShorthandSyntax && formattedPropValue === '{false}' && !hasDefaultValue) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += \"\".concat(name);\n    attributeFormattedMultiline += \"\".concat(name);\n  } else {\n    attributeFormattedInline += \"\".concat(name, \"=\").concat(formattedPropValue);\n    attributeFormattedMultiline += \"\".concat(name, \"=\").concat(formattedPropValue);\n  }\n  return {\n    attributeFormattedInline: attributeFormattedInline,\n    attributeFormattedMultiline: attributeFormattedMultiline,\n    isMultilineAttribute: isMultilineAttribute\n  };\n};\nvar mergeSiblingPlainStringChildrenReducer = function (previousNodes, currentNode) {\n  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);\n  var previousNode = previousNodes[previousNodes.length - 1];\n  if (previousNode && (currentNode.type === 'string' || currentNode.type === 'number') && (previousNode.type === 'string' || previousNode.type === 'number')) {\n    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n    nodes.push(currentNode);\n  }\n  return nodes;\n};\nvar isKeyOrRefProps = function isKeyOrRefProps(propName) {\n  return ['key', 'ref'].includes(propName);\n};\nvar sortPropsByNames = function (shouldSortUserProps) {\n  return function (props) {\n    var haveKeyProp = props.includes('key');\n    var haveRefProp = props.includes('ref');\n    var userPropsOnly = props.filter(function (oneProp) {\n      return !isKeyOrRefProps(oneProp);\n    });\n    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) // We use basic lexical order\n    : _toConsumableArray(userPropsOnly);\n    if (haveRefProp) {\n      sortedProps.unshift('ref');\n    }\n    if (haveKeyProp) {\n      sortedProps.unshift('key');\n    }\n    return sortedProps;\n  };\n};\nfunction createPropFilter(props, filter) {\n  if (Array.isArray(filter)) {\n    return function (key) {\n      return filter.indexOf(key) === -1;\n    };\n  } else {\n    return function (key) {\n      return filter(props[key], key);\n    };\n  }\n}\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n  if (element.type === 'string') {\n    return formattedElement.split('\\n').map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n      return \"\".concat(spacer(lvl, tabStop)).concat(line);\n    }).join('\\n');\n  }\n  return formattedElement;\n};\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);\n  };\n};\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\nvar formatReactElementNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    _node$displayName = node.displayName,\n    displayName = _node$displayName === void 0 ? '' : _node$displayName,\n    childrens = node.childrens,\n    _node$props = node.props,\n    props = _node$props === void 0 ? {} : _node$props,\n    _node$defaultProps = node.defaultProps,\n    defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;\n  if (type !== 'ReactElement') {\n    throw new Error(\"The \\\"formatReactElementNode\\\" function could only format node of type \\\"ReactElement\\\". Given:  \".concat(type));\n  }\n  var filterProps = options.filterProps,\n    maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n    showDefaultProps = options.showDefaultProps,\n    sortProps = options.sortProps,\n    tabStop = options.tabStop;\n  var out = \"<\".concat(displayName);\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  var propFilter = createPropFilter(props, filterProps);\n  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(propFilter).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n  attributes.forEach(function (attributeName) {\n    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n      attributeFormattedInline = _formatProp.attributeFormattedInline,\n      attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n      isMultilineAttribute = _formatProp.isMultilineAttribute;\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\".concat(spacer(lvl, tabStop));\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += '>';\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\".concat(spacer(newLvl, tabStop)) : '');\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += \"</\".concat(displayName, \">\");\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += ' ';\n    }\n    out += '/>';\n  }\n  return out;\n};\nvar REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nvar REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\nvar toReactElementTreeNode = function toReactElementTreeNode(displayName, key, childrens) {\n  var props = {};\n  if (key) {\n    props = {\n      key: key\n    };\n  }\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: {},\n    childrens: childrens\n  };\n};\nvar isKeyedFragment = function isKeyedFragment(_ref) {\n  var key = _ref.key;\n  return Boolean(key);\n};\nvar hasNoChildren = function hasNoChildren(_ref2) {\n  var childrens = _ref2.childrens;\n  return childrens.length === 0;\n};\nvar formatReactFragmentNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    key = node.key,\n    childrens = node.childrens;\n  if (type !== 'ReactFragment') {\n    throw new Error(\"The \\\"formatReactFragmentNode\\\" function could only format node of type \\\"ReactFragment\\\". Given: \".concat(type));\n  }\n  var useFragmentShortSyntax = options.useFragmentShortSyntax;\n  var displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);\n};\nvar jsxStopChars = ['<', '>', '{', '}'];\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\nvar escape = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n  return \"{`\".concat(s, \"`}\");\n};\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n  return result;\n};\nvar formatTreeNode = function (node, inline, lvl, options) {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n  if (node.type === 'string') {\n    return node.value ? \"\".concat(preserveTrailingSpace(escape(String(node.value)))) : '';\n  }\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n  throw new TypeError(\"Unknow format type \\\"\".concat(node.type, \"\\\"\"));\n};\nvar formatTree = function (node, options) {\n  return formatTreeNode(node, false, 0, options);\n};\nvar reactElementToJsxString = function reactElementToJsxString(element) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$filterProps = _ref.filterProps,\n    filterProps = _ref$filterProps === void 0 ? [] : _ref$filterProps,\n    _ref$showDefaultProps = _ref.showDefaultProps,\n    showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps,\n    _ref$showFunctions = _ref.showFunctions,\n    showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions,\n    functionValue = _ref.functionValue,\n    _ref$tabStop = _ref.tabStop,\n    tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop,\n    _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax,\n    useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth,\n    _ref$useFragmentShort = _ref.useFragmentShortSyntax,\n    useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort,\n    _ref$sortProps = _ref.sortProps,\n    sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps,\n    maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength,\n    displayName = _ref.displayName;\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n  var options = {\n    filterProps: filterProps,\n    showDefaultProps: showDefaultProps,\n    showFunctions: showFunctions,\n    functionValue: functionValue,\n    tabStop: tabStop,\n    useBooleanShorthandSyntax: useBooleanShorthandSyntax,\n    useFragmentShortSyntax: useFragmentShortSyntax,\n    sortProps: sortProps,\n    maxInlineAttributesLineLength: maxInlineAttributesLineLength,\n    displayName: displayName\n  };\n  return formatTree(parseReactElement(element, options), options);\n};\nexports[\"default\"] = reactElementToJsxString;\nexports.inlineFunction = inlineFunction;\nexports.preserveFunctionLineBreak = preserveFunctionLineBreak;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}