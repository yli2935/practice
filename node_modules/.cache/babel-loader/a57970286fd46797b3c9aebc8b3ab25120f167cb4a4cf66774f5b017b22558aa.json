{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar isPlainObject = require('is-plain-object');\nvar React = require('react');\nvar prettyPrintObject = require('@base2/pretty-print-object');\nvar reactIs = require('react-is');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar spacer = function (times, tabStop) {\n  if (times === 0) {\n    return '';\n  }\n  return new Array(times * tabStop).fill(' ').join('');\n};\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction safeSortObject(value, seen) {\n  // return non-object value as is\n  if (value === null || _typeof(value) !== 'object') {\n    return value;\n  } // return date, regexp and react element values as is\n\n  if (value instanceof Date || value instanceof RegExp || /*#__PURE__*/React__namespace.isValidElement(value)) {\n    return value;\n  }\n  seen.add(value); // make a copy of array with each item passed through the sorting algorithm\n\n  if (Array.isArray(value)) {\n    return value.map(function (v) {\n      return safeSortObject(v, seen);\n    });\n  } // make a copy of object with key sorted\n\n  return Object.keys(value).sort().reduce(function (result, key) {\n    if (key === '_owner') {\n      return result;\n    }\n    if (key === 'current' || seen.has(value[key])) {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = '[Circular]';\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = safeSortObject(value[key], seen);\n    }\n    return result;\n  }, {});\n}\nfunction sortObject(value) {\n  return safeSortObject(value, new WeakSet());\n}\n\n/* eslint-disable no-use-before-define */\nvar createStringTreeNode = function createStringTreeNode(value) {\n  return {\n    type: 'string',\n    value: value\n  };\n};\nvar createNumberTreeNode = function createNumberTreeNode(value) {\n  return {\n    type: 'number',\n    value: value\n  };\n};\nvar createReactElementTreeNode = function createReactElementTreeNode(displayName, props, defaultProps, childrens) {\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: defaultProps,\n    childrens: childrens\n  };\n};\nvar createReactFragmentTreeNode = function createReactFragmentTreeNode(key, childrens) {\n  return {\n    type: 'ReactFragment',\n    key: key,\n    childrens: childrens\n  };\n};\nvar supportFragment = Boolean(React.Fragment);\nvar getFunctionTypeName = function getFunctionTypeName(functionType) {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\nvar getWrappedComponentDisplayName = function getWrappedComponentDisplayName(Component) {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === reactIs.Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === reactIs.ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n}; // heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case reactIs.isForwardRef(element):\n    case reactIs.isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case reactIs.isContextConsumer(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Consumer\");\n    case reactIs.isContextProvider(element):\n      return \"\".concat(element.type._context.displayName || 'Context', \".Provider\");\n    case reactIs.isLazy(element):\n      return 'Lazy';\n    case reactIs.isProfiler(element):\n      return 'Profiler';\n    case reactIs.isStrictMode(element):\n      return 'StrictMode';\n    case reactIs.isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== 'children';\n};\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== '';\n};\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n    displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (! /*#__PURE__*/React__default[\"default\"].isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\".concat(_typeof(element), \"`\"));\n  }\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n  var key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  var childrens = React__default[\"default\"].Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n  if (supportFragment && element.type === React.Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n  return createReactElementTreeNode(displayName, props, defaultProps, childrens);\n};\nfunction noRefCheck() {}\nvar inlineFunction = function inlineFunction(fn) {\n  return fn.toString().split('\\n').map(function (line) {\n    return line.trim();\n  }).join('');\n};\nvar preserveFunctionLineBreak = function preserveFunctionLineBreak(fn) {\n  return fn.toString();\n};\nvar defaultFunctionValue = inlineFunction;\nvar formatFunction = function (fn, options) {\n  var _options$functionValu = options.functionValue,\n    functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu,\n    showFunctions = options.showFunctions;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n  return functionValue(fn);\n};\nvar formatComplexDataStructure = function (value, inline, lvl, options) {\n  var normalizedValue = sortObject(value);\n  var stringifiedValue = prettyPrintObject.prettyPrint(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n      if (currentValue && /*#__PURE__*/React.isValidElement(currentValue)) {\n        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);\n      }\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n      return originalResult;\n    }\n  });\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, ' ').replace(/{ /g, '{').replace(/ }/g, '}').replace(/\\[ /g, '[').replace(/ ]/g, ']');\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n  return stringifiedValue.replace(/\\t/g, spacer(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\".concat(spacer(lvl + 1, options.tabStop), \"$1\"));\n};\nvar escape$1 = function escape(s) {\n  return s.replace(/\"/g, '&quot;');\n};\nvar formatPropValue = function formatPropValue(propValue, inline, lvl, options) {\n  if (typeof propValue === 'number') {\n    return \"{\".concat(String(propValue), \"}\");\n  }\n  if (typeof propValue === 'string') {\n    return \"\\\"\".concat(escape$1(propValue), \"\\\"\");\n  } // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n\n  if (_typeof(propValue) === 'symbol') {\n    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\\((.*)\\)/, '$1');\n    if (!symbolDescription) {\n      return \"{Symbol()}\";\n    }\n    return \"{Symbol('\".concat(symbolDescription, \"')}\");\n  }\n  if (typeof propValue === 'function') {\n    return \"{\".concat(formatFunction(propValue, options), \"}\");\n  }\n  if ( /*#__PURE__*/React.isValidElement(propValue)) {\n    return \"{\".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), \"}\");\n  }\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return \"{new Date(NaN)}\";\n    }\n    return \"{new Date(\\\"\".concat(propValue.toISOString(), \"\\\")}\");\n  }\n  if (isPlainObject.isPlainObject(propValue) || Array.isArray(propValue)) {\n    return \"{\".concat(formatComplexDataStructure(propValue, inline, lvl, options), \"}\");\n  }\n  return \"{\".concat(String(propValue), \"}\");\n};\nvar formatProp = function (name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\"The prop \\\"\".concat(name, \"\\\" has no value and no default: could not be formatted\"));\n  }\n  var usedValue = hasValue ? value : defaultValue;\n  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax,\n    tabStop = options.tabStop;\n  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n  var attributeFormattedInline = ' ';\n  var attributeFormattedMultiline = \"\\n\".concat(spacer(lvl + 1, tabStop));\n  var isMultilineAttribute = formattedPropValue.includes('\\n');\n  if (useBooleanShorthandSyntax && formattedPropValue === '{false}' && !hasDefaultValue) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += \"\".concat(name);\n    attributeFormattedMultiline += \"\".concat(name);\n  } else {\n    attributeFormattedInline += \"\".concat(name, \"=\").concat(formattedPropValue);\n    attributeFormattedMultiline += \"\".concat(name, \"=\").concat(formattedPropValue);\n  }\n  return {\n    attributeFormattedInline: attributeFormattedInline,\n    attributeFormattedMultiline: attributeFormattedMultiline,\n    isMultilineAttribute: isMultilineAttribute\n  };\n};\nvar mergeSiblingPlainStringChildrenReducer = function (previousNodes, currentNode) {\n  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);\n  var previousNode = previousNodes[previousNodes.length - 1];\n  if (previousNode && (currentNode.type === 'string' || currentNode.type === 'number') && (previousNode.type === 'string' || previousNode.type === 'number')) {\n    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n    nodes.push(currentNode);\n  }\n  return nodes;\n};\nvar isKeyOrRefProps = function isKeyOrRefProps(propName) {\n  return ['key', 'ref'].includes(propName);\n};\nvar sortPropsByNames = function (shouldSortUserProps) {\n  return function (props) {\n    var haveKeyProp = props.includes('key');\n    var haveRefProp = props.includes('ref');\n    var userPropsOnly = props.filter(function (oneProp) {\n      return !isKeyOrRefProps(oneProp);\n    });\n    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) // We use basic lexical order\n    : _toConsumableArray(userPropsOnly);\n    if (haveRefProp) {\n      sortedProps.unshift('ref');\n    }\n    if (haveKeyProp) {\n      sortedProps.unshift('key');\n    }\n    return sortedProps;\n  };\n};\nfunction createPropFilter(props, filter) {\n  if (Array.isArray(filter)) {\n    return function (key) {\n      return filter.indexOf(key) === -1;\n    };\n  } else {\n    return function (key) {\n      return filter(props[key], key);\n    };\n  }\n}\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n  if (element.type === 'string') {\n    return formattedElement.split('\\n').map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n      return \"\".concat(spacer(lvl, tabStop)).concat(line);\n    }).join('\\n');\n  }\n  return formattedElement;\n};\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);\n  };\n};\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\nvar formatReactElementNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    _node$displayName = node.displayName,\n    displayName = _node$displayName === void 0 ? '' : _node$displayName,\n    childrens = node.childrens,\n    _node$props = node.props,\n    props = _node$props === void 0 ? {} : _node$props,\n    _node$defaultProps = node.defaultProps,\n    defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;\n  if (type !== 'ReactElement') {\n    throw new Error(\"The \\\"formatReactElementNode\\\" function could only format node of type \\\"ReactElement\\\". Given:  \".concat(type));\n  }\n  var filterProps = options.filterProps,\n    maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n    showDefaultProps = options.showDefaultProps,\n    sortProps = options.sortProps,\n    tabStop = options.tabStop;\n  var out = \"<\".concat(displayName);\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  var propFilter = createPropFilter(props, filterProps);\n  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(propFilter).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n  attributes.forEach(function (attributeName) {\n    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n      attributeFormattedInline = _formatProp.attributeFormattedInline,\n      attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n      isMultilineAttribute = _formatProp.isMultilineAttribute;\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\".concat(spacer(lvl, tabStop));\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += '>';\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\".concat(spacer(newLvl, tabStop)) : '');\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += \"</\".concat(displayName, \">\");\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += ' ';\n    }\n    out += '/>';\n  }\n  return out;\n};\nvar REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nvar REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\nvar toReactElementTreeNode = function toReactElementTreeNode(displayName, key, childrens) {\n  var props = {};\n  if (key) {\n    props = {\n      key: key\n    };\n  }\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: {},\n    childrens: childrens\n  };\n};\nvar isKeyedFragment = function isKeyedFragment(_ref) {\n  var key = _ref.key;\n  return Boolean(key);\n};\nvar hasNoChildren = function hasNoChildren(_ref2) {\n  var childrens = _ref2.childrens;\n  return childrens.length === 0;\n};\nvar formatReactFragmentNode = function (node, inline, lvl, options) {\n  var type = node.type,\n    key = node.key,\n    childrens = node.childrens;\n  if (type !== 'ReactFragment') {\n    throw new Error(\"The \\\"formatReactFragmentNode\\\" function could only format node of type \\\"ReactFragment\\\". Given: \".concat(type));\n  }\n  var useFragmentShortSyntax = options.useFragmentShortSyntax;\n  var displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);\n};\nvar jsxStopChars = ['<', '>', '{', '}'];\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\nvar escape = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n  return \"{`\".concat(s, \"`}\");\n};\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n  return result;\n};\nvar formatTreeNode = function (node, inline, lvl, options) {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n  if (node.type === 'string') {\n    return node.value ? \"\".concat(preserveTrailingSpace(escape(String(node.value)))) : '';\n  }\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n  throw new TypeError(\"Unknow format type \\\"\".concat(node.type, \"\\\"\"));\n};\nvar formatTree = function (node, options) {\n  return formatTreeNode(node, false, 0, options);\n};\nvar reactElementToJsxString = function reactElementToJsxString(element) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$filterProps = _ref.filterProps,\n    filterProps = _ref$filterProps === void 0 ? [] : _ref$filterProps,\n    _ref$showDefaultProps = _ref.showDefaultProps,\n    showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps,\n    _ref$showFunctions = _ref.showFunctions,\n    showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions,\n    functionValue = _ref.functionValue,\n    _ref$tabStop = _ref.tabStop,\n    tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop,\n    _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax,\n    useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth,\n    _ref$useFragmentShort = _ref.useFragmentShortSyntax,\n    useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort,\n    _ref$sortProps = _ref.sortProps,\n    sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps,\n    maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength,\n    displayName = _ref.displayName;\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n  var options = {\n    filterProps: filterProps,\n    showDefaultProps: showDefaultProps,\n    showFunctions: showFunctions,\n    functionValue: functionValue,\n    tabStop: tabStop,\n    useBooleanShorthandSyntax: useBooleanShorthandSyntax,\n    useFragmentShortSyntax: useFragmentShortSyntax,\n    sortProps: sortProps,\n    maxInlineAttributesLineLength: maxInlineAttributesLineLength,\n    displayName: displayName\n  };\n  return formatTree(parseReactElement(element, options), options);\n};\nexports[\"default\"] = reactElementToJsxString;\nexports.inlineFunction = inlineFunction;\nexports.preserveFunctionLineBreak = preserveFunctionLineBreak;","map":{"version":3,"names":["spacer","times","tabStop","Array","fill","join","safeSortObject","value","seen","_typeof","Date","RegExp","React__namespace","isValidElement","add","isArray","map","v","Object","keys","sort","reduce","result","key","has","sortObject","WeakSet","createStringTreeNode","type","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","React","Fragment","getFunctionTypeName","functionType","name","getWrappedComponentDisplayName","Component","$$typeof","reactIs","Memo","ForwardRef","render","getReactElementDisplayName","element","isForwardRef","isMemo","isContextConsumer","concat","_context","isContextProvider","isLazy","isProfiler","isStrictMode","isSuspense","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","filter","forEach","parseReactElement","options","_options$displayName","displayNameFn","React__default","Error","ref","search","Children","toArray","child","noRefCheck","inlineFunction","fn","toString","split","line","trim","preserveFunctionLineBreak","defaultFunctionValue","formatFunction","_options$functionValu","functionValue","showFunctions","formatComplexDataStructure","inline","lvl","normalizedValue","stringifiedValue","prettyPrintObject","prettyPrint","transform","currentObj","prop","originalResult","currentValue","formatTreeNode","replace","escape$1","escape","s","formatPropValue","propValue","String","symbolDescription","valueOf","isNaN","toISOString","isPlainObject","formatProp","hasValue","hasDefaultValue","defaultValue","usedValue","useBooleanShorthandSyntax","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","includes","mergeSiblingPlainStringChildrenReducer","previousNodes","currentNode","nodes","slice","length","previousNode","push","isKeyOrRefProps","sortPropsByNames","shouldSortUserProps","haveKeyProp","haveRefProp","userPropsOnly","oneProp","sortedProps","_toConsumableArray","unshift","createPropFilter","indexOf","compensateMultilineStringElementIndentation","formattedElement","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","maxInlineAttributesLineLength","shouldRenderMultilineAttr","containsMultilineAttr","formatReactElementNode","node","_node$displayName","_node$props","_node$defaultProps","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","visibleAttributeNames","propFilter","defaultPropName","attributeName","_formatProp","newLvl","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","_ref","hasNoChildren","_ref2","formatReactFragmentNode","useFragmentShortSyntax","jsxStopChars","shouldBeEscaped","some","jsxStopChar","preserveTrailingSpace","endsWith","startsWith","TypeError","formatTree","reactElementToJsxString","arguments","undefined","_ref$filterProps","_ref$showDefaultProps","_ref$showFunctions","_ref$tabStop","_ref$useBooleanShorth","_ref$useFragmentShort","_ref$sortProps"],"sources":["/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/spacer.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/sortObject.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/tree.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/parser/parseReactElement.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatFunction.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatComplexDataStructure.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatPropValue.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatProp.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/mergeSiblingPlainStringChildrenReducer.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/sortPropsByNames.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/createPropFilter.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatReactElementNode.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatReactFragmentNode.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatTreeNode.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/formatter/formatTree.js","/Users/liyaguang/udemy/Reacl Learning/practie/practice/node_modules/react-element-to-jsx-string/src/index.js"],"sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/* @flow */\nimport * as React from 'react';\n\nfunction safeSortObject(value: any, seen: WeakSet<any>): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date, regexp and react element values as is\n  if (\n    value instanceof Date ||\n    value instanceof RegExp ||\n    React.isValidElement(value)\n  ) {\n    return value;\n  }\n\n  seen.add(value);\n\n  // make a copy of array with each item passed through the sorting algorithm\n  if (Array.isArray(value)) {\n    return value.map(v => safeSortObject(v, seen));\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current' || seen.has(value[key])) {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = safeSortObject(value[key], seen);\n      }\n      return result;\n    }, {});\n}\n\nexport default function sortObject(value: any): any {\n  return safeSortObject(value, new WeakSet());\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport {\n  ForwardRef,\n  isContextConsumer,\n  isContextProvider,\n  isForwardRef,\n  isLazy,\n  isMemo,\n  isProfiler,\n  isStrictMode,\n  isSuspense,\n  Memo,\n} from 'react-is';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getFunctionTypeName = (functionType): string => {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\n\nconst getWrappedComponentDisplayName = (Component: *): string => {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n};\n\n// heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\nconst getReactElementDisplayName = (element: ReactElement<*>): string => {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case isForwardRef(element):\n    case isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case isContextConsumer(element):\n      return `${element.type._context.displayName || 'Context'}.Consumer`;\n    case isContextProvider(element):\n      return `${element.type._context.displayName || 'Context'}.Provider`;\n    case isLazy(element):\n      return 'Lazy';\n    case isProfiler(element):\n      return 'Profiler';\n    case isStrictMode(element):\n      return 'StrictMode';\n    case isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport { isPlainObject } from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return `{new Date(NaN)}`;\n    }\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n","/* @flow */\n\nexport default function createPropFilter(\n  props: {},\n  filter: string[] | ((any, string) => boolean)\n) {\n  if (Array.isArray(filter)) {\n    return (key: string) => filter.indexOf(key) === -1;\n  } else {\n    return (key: string) => filter(props[key], key);\n  }\n}\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport createPropFilter from './createPropFilter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  const propFilter = createPropFilter(props, filterProps);\n\n  Object.keys(props)\n    .filter(propFilter)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(propFilter)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}