{"ast":null,"code":"import { findSpring, calcAngularFreq } from './find-spring.mjs';\nimport { velocityPerSecond } from '../../utils/velocity-per-second.mjs';\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  };\n  // stiffness/damping/mass overrides duration/bounce\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = {\n      ...springOptions,\n      ...derived,\n      velocity: 0.0,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nconst velocitySampleDuration = 5;\n/**\n * This is based on the spring implementation of Wobble https://github.com/skevy/wobble\n */\nfunction spring(_ref) {\n  let {\n    keyframes,\n    restSpeed = 2,\n    restDelta = 0.01,\n    ...options\n  } = _ref;\n  let origin = keyframes[0];\n  let target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  function createSpring() {\n    const initialDelta = target - origin;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    /**\n     * If we're working within what looks like a 0-1 range, change the default restDelta\n     * to 0.01\n     */\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(target - origin) / 100, 0.4);\n    }\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      // Underdamped spring\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      // Critically damped spring\n      resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      // Overdamped spring\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        // When performing sinh or cosh values can hit Infinity so we cap them here\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            const prevT = Math.max(0, t - velocitySampleDuration);\n            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t - prevT);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    },\n    flipTarget: () => {\n      initialVelocity = -initialVelocity;\n      [origin, target] = [target, origin];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = _t => 0;\nexport { spring };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}