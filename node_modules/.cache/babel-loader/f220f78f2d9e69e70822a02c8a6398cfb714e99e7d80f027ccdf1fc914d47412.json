{"ast":null,"code":"'use strict';\n\n/* global window, self */\n\n// istanbul ignore next - Don't allow Prism to run on page load in browser or\n// to start messaging from workers.\nvar ctx = typeof globalThis === 'object' ? globalThis : typeof self === 'object' ? self : typeof window === 'object' ? window : typeof global === 'object' ? global : {};\nvar restore = capture();\nctx.Prism = {\n  manual: true,\n  disableWorkerMessageHandler: true\n};\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prismâ€™s originals.\nvar h = require('hastscript');\nvar decode = require('parse-entities');\nvar Prism = require('prismjs/components/prism-core');\nvar markup = require('./lang/markup');\nvar css = require('./lang/css');\nvar clike = require('./lang/clike');\nvar js = require('./lang/javascript');\nrestore();\nvar own = {}.hasOwnProperty;\n\n// Inherit.\nfunction Refractor() {}\nRefractor.prototype = Prism;\n\n// Construct.\nvar refract = new Refractor();\n\n// Expose.\nmodule.exports = refract;\n\n// Create.\nrefract.highlight = highlight;\nrefract.register = register;\nrefract.alias = alias;\nrefract.registered = registered;\nrefract.listLanguages = listLanguages;\n\n// Register bundled grammars.\nregister(markup);\nregister(css);\nregister(clike);\nregister(js);\nrefract.util.encode = encode;\nrefract.Token.stringify = stringify;\nfunction register(grammar) {\n  if (typeof grammar !== 'function' || !grammar.displayName) {\n    throw new Error('Expected `function` for `grammar`, got `' + grammar + '`');\n  }\n\n  // Do not duplicate registrations.\n  if (refract.languages[grammar.displayName] === undefined) {\n    grammar(refract);\n  }\n}\nfunction alias(name, alias) {\n  var languages = refract.languages;\n  var map = name;\n  var key;\n  var list;\n  var length;\n  var index;\n  if (alias) {\n    map = {};\n    map[name] = alias;\n  }\n  for (key in map) {\n    list = map[key];\n    list = typeof list === 'string' ? [list] : list;\n    length = list.length;\n    index = -1;\n    while (++index < length) {\n      languages[list[index]] = languages[key];\n    }\n  }\n}\nfunction highlight(value, name) {\n  var sup = Prism.highlight;\n  var grammar;\n  if (typeof value !== 'string') {\n    throw new Error('Expected `string` for `value`, got `' + value + '`');\n  }\n\n  // `name` is a grammar object.\n  if (refract.util.type(name) === 'Object') {\n    grammar = name;\n    name = null;\n  } else {\n    if (typeof name !== 'string') {\n      throw new Error('Expected `string` for `name`, got `' + name + '`');\n    }\n    if (own.call(refract.languages, name)) {\n      grammar = refract.languages[name];\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered');\n    }\n  }\n  return sup.call(this, value, grammar, name);\n}\nfunction registered(language) {\n  if (typeof language !== 'string') {\n    throw new Error('Expected `string` for `language`, got `' + language + '`');\n  }\n  return own.call(refract.languages, language);\n}\nfunction listLanguages() {\n  var languages = refract.languages;\n  var list = [];\n  var language;\n  for (language in languages) {\n    if (own.call(languages, language) && typeof languages[language] === 'object') {\n      list.push(language);\n    }\n  }\n  return list;\n}\nfunction stringify(value, language, parent) {\n  var env;\n  if (typeof value === 'string') {\n    return {\n      type: 'text',\n      value: value\n    };\n  }\n  if (refract.util.type(value) === 'Array') {\n    return stringifyAll(value, language);\n  }\n  env = {\n    type: value.type,\n    content: refract.Token.stringify(value.content, language, parent),\n    tag: 'span',\n    classes: ['token', value.type],\n    attributes: {},\n    language: language,\n    parent: parent\n  };\n  if (value.alias) {\n    env.classes = env.classes.concat(value.alias);\n  }\n  refract.hooks.run('wrap', env);\n  return h(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);\n}\nfunction stringifyAll(values, language) {\n  var result = [];\n  var length = values.length;\n  var index = -1;\n  var value;\n  while (++index < length) {\n    value = values[index];\n    if (value !== '' && value !== null && value !== undefined) {\n      result.push(value);\n    }\n  }\n  index = -1;\n  length = result.length;\n  while (++index < length) {\n    value = result[index];\n    result[index] = refract.Token.stringify(value, language, result);\n  }\n  return result;\n}\nfunction encode(tokens) {\n  return tokens;\n}\nfunction attributes(attrs) {\n  var key;\n  for (key in attrs) {\n    attrs[key] = decode(attrs[key]);\n  }\n  return attrs;\n}\nfunction capture() {\n  var defined = ('Prism' in ctx);\n  /* istanbul ignore next */\n  var current = defined ? ctx.Prism : undefined;\n  return restore;\n  function restore() {\n    /* istanbul ignore else - Clean leaks after Prism. */\n    if (defined) {\n      ctx.Prism = current;\n    } else {\n      delete ctx.Prism;\n    }\n    defined = undefined;\n    current = undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}