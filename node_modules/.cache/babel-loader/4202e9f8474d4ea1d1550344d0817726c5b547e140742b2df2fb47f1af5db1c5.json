{"ast":null,"code":"'use strict';\n\nvar legacy = require('character-entities-legacy');\nvar invalid = require('character-reference-invalid');\nvar decimal = require('is-decimal');\nvar hexadecimal = require('is-hexadecimal');\nvar alphanumerical = require('is-alphanumerical');\nvar decodeEntity = require('./decode-entity');\nmodule.exports = parseEntities;\nvar own = {}.hasOwnProperty;\nvar fromCharCode = String.fromCharCode;\nvar noop = Function.prototype;\n\n// Default settings.\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n};\n\n// Characters.\nvar tab = 9; // '\\t'\nvar lineFeed = 10; // '\\n'\nvar formFeed = 12; // '\\f'\nvar space = 32; // ' '\nvar ampersand = 38; // '&'\nvar semicolon = 59; // ';'\nvar lessThan = 60; // '<'\nvar equalsTo = 61; // '='\nvar numberSign = 35; // '#'\nvar uppercaseX = 88; // 'X'\nvar lowercaseX = 120; // 'x'\nvar replacementCharacter = 65533; // '�'\n\n// Reference types.\nvar name = 'named';\nvar hexa = 'hexadecimal';\nvar deci = 'decimal';\n\n// Map of bases.\nvar bases = {};\nbases[hexa] = 16;\nbases[deci] = 10;\n\n// Map of types to tests.\n// Each type of character reference accepts different characters.\n// This test is used to detect whether a reference has ended (as the semicolon\n// is not strictly needed).\nvar tests = {};\ntests[name] = alphanumerical;\ntests[deci] = decimal;\ntests[hexa] = hexadecimal;\n\n// Warning types.\nvar namedNotTerminated = 1;\nvar numericNotTerminated = 2;\nvar namedEmpty = 3;\nvar numericEmpty = 4;\nvar namedUnknown = 5;\nvar numericDisallowed = 6;\nvar numericProhibited = 7;\n\n// Warning messages.\nvar messages = {};\nmessages[namedNotTerminated] = 'Named character references must be terminated by a semicolon';\nmessages[numericNotTerminated] = 'Numeric character references must be terminated by a semicolon';\nmessages[namedEmpty] = 'Named character references cannot be empty';\nmessages[numericEmpty] = 'Numeric character references cannot be empty';\nmessages[namedUnknown] = 'Named character references must be known';\nmessages[numericDisallowed] = 'Numeric character references cannot be disallowed';\nmessages[numericProhibited] = 'Numeric character references cannot be outside the permissible Unicode range';\n\n// Wrap to ensure clean parameters are given to `parse`.\nfunction parseEntities(value, options) {\n  var settings = {};\n  var option;\n  var key;\n  if (!options) {\n    options = {};\n  }\n  for (key in defaults) {\n    option = options[key];\n    settings[key] = option === null || option === undefined ? defaults[key] : option;\n  }\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || [];\n    settings.position = settings.position.start;\n  }\n  return parse(value, settings);\n}\n\n// Parse entities.\n// eslint-disable-next-line complexity\nfunction parse(value, settings) {\n  var additional = settings.additional;\n  var nonTerminated = settings.nonTerminated;\n  var handleText = settings.text;\n  var handleReference = settings.reference;\n  var handleWarning = settings.warning;\n  var textContext = settings.textContext;\n  var referenceContext = settings.referenceContext;\n  var warningContext = settings.warningContext;\n  var pos = settings.position;\n  var indent = settings.indent || [];\n  var length = value.length;\n  var index = 0;\n  var lines = -1;\n  var column = pos.column || 1;\n  var line = pos.line || 1;\n  var queue = '';\n  var result = [];\n  var entityCharacters;\n  var namedEntity;\n  var terminated;\n  var characters;\n  var character;\n  var reference;\n  var following;\n  var warning;\n  var reason;\n  var output;\n  var entity;\n  var begin;\n  var start;\n  var type;\n  var test;\n  var prev;\n  var next;\n  var diff;\n  var end;\n  if (typeof additional === 'string') {\n    additional = additional.charCodeAt(0);\n  }\n\n  // Cache the current point.\n  prev = now();\n\n  // Wrap `handleWarning`.\n  warning = handleWarning ? parseError : noop;\n\n  // Ensure the algorithm walks over the first character and the end\n  // (inclusive).\n  index--;\n  length++;\n  while (++index < length) {\n    // If the previous character was a newline.\n    if (character === lineFeed) {\n      column = indent[lines] || 1;\n    }\n    character = value.charCodeAt(index);\n    if (character === ampersand) {\n      following = value.charCodeAt(index + 1);\n\n      // The behaviour depends on the identity of the next character.\n      if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character);\n        column++;\n        continue;\n      }\n      start = index + 1;\n      begin = start;\n      end = start;\n      if (following === numberSign) {\n        // Numerical entity.\n        end = ++begin;\n\n        // The behaviour further depends on the next character.\n        following = value.charCodeAt(end);\n        if (following === uppercaseX || following === lowercaseX) {\n          // ASCII hex digits.\n          type = hexa;\n          end = ++begin;\n        } else {\n          // ASCII digits.\n          type = deci;\n        }\n      } else {\n        // Named entity.\n        type = name;\n      }\n      entityCharacters = '';\n      entity = '';\n      characters = '';\n      test = tests[type];\n      end--;\n      while (++end < length) {\n        following = value.charCodeAt(end);\n        if (!test(following)) {\n          break;\n        }\n        characters += fromCharCode(following);\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === name && own.call(legacy, characters)) {\n          entityCharacters = characters;\n          entity = legacy[characters];\n        }\n      }\n      terminated = value.charCodeAt(end) === semicolon;\n      if (terminated) {\n        end++;\n        namedEntity = type === name ? decodeEntity(characters) : false;\n        if (namedEntity) {\n          entityCharacters = characters;\n          entity = namedEntity;\n        }\n      }\n      diff = 1 + end - start;\n      if (!terminated && !nonTerminated) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) entity is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== name) {\n          warning(numericEmpty, diff);\n        }\n      } else if (type === name) {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !entity) {\n          warning(namedUnknown, 1);\n        } else {\n          // If theres something after an entity name which is not known, cap\n          // the reference.\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length;\n            diff = 1 + end - begin;\n            terminated = false;\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            reason = entityCharacters ? namedNotTerminated : namedEmpty;\n            if (settings.attribute) {\n              following = value.charCodeAt(end);\n              if (following === equalsTo) {\n                warning(reason, diff);\n                entity = null;\n              } else if (alphanumerical(following)) {\n                entity = null;\n              } else {\n                warning(reason, diff);\n              }\n            } else {\n              warning(reason, diff);\n            }\n          }\n        }\n        reference = entity;\n      } else {\n        if (!terminated) {\n          // All non-terminated numeric entities are not rendered, and trigger a\n          // warning.\n          warning(numericNotTerminated, diff);\n        }\n\n        // When terminated and number, parse as either hexadecimal or decimal.\n        reference = parseInt(characters, bases[type]);\n\n        // Trigger a warning when the parsed number is prohibited, and replace\n        // with replacement character.\n        if (prohibited(reference)) {\n          warning(numericProhibited, diff);\n          reference = fromCharCode(replacementCharacter);\n        } else if (reference in invalid) {\n          // Trigger a warning when the parsed number is disallowed, and replace\n          // by an alternative.\n          warning(numericDisallowed, diff);\n          reference = invalid[reference];\n        } else {\n          // Parse the number.\n          output = '';\n\n          // Trigger a warning when the parsed number should not be used.\n          if (disallowed(reference)) {\n            warning(numericDisallowed, diff);\n          }\n\n          // Stringify the number.\n          if (reference > 0xffff) {\n            reference -= 0x10000;\n            output += fromCharCode(reference >>> (10 & 0x3ff) | 0xd800);\n            reference = 0xdc00 | reference & 0x3ff;\n          }\n          reference = output + fromCharCode(reference);\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat an entity.\n      if (reference) {\n        flush();\n        prev = now();\n        index = end - 1;\n        column += end - start + 1;\n        result.push(reference);\n        next = now();\n        next.offset++;\n        if (handleReference) {\n          handleReference.call(referenceContext, reference, {\n            start: prev,\n            end: next\n          }, value.slice(start - 1, end));\n        }\n        prev = next;\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end);\n        queue += characters;\n        column += characters.length;\n        index = end - 1;\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (character === 10 // Line feed\n      ) {\n        line++;\n        lines++;\n        column = 0;\n      }\n      if (character === character) {\n        queue += fromCharCode(character);\n        column++;\n      } else {\n        flush();\n      }\n    }\n  }\n\n  // Return the reduced nodes.\n  return result.join('');\n\n  // Get current position.\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    };\n  }\n\n  // “Throw” a parse-error: a warning.\n  function parseError(code, offset) {\n    var position = now();\n    position.column += offset;\n    position.offset += offset;\n    handleWarning.call(warningContext, messages[code], position, code);\n  }\n\n  // Flush `queue` (normal text).\n  // Macro invoked before each entity and at the end of `value`.\n  // Does nothing when `queue` is empty.\n  function flush() {\n    if (queue) {\n      result.push(queue);\n      if (handleText) {\n        handleText.call(textContext, queue, {\n          start: prev,\n          end: now()\n        });\n      }\n      queue = '';\n    }\n  }\n}\n\n// Check if `character` is outside the permissible unicode range.\nfunction prohibited(code) {\n  return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;\n}\n\n// Check if `character` is disallowed.\nfunction disallowed(code) {\n  return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}