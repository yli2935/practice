{"ast":null,"code":"function decay(_ref) {\n  let {\n    /**\n     * The decay animation dynamically calculates an end of the animation\n     * based on the initial keyframe, so we only need to define a single keyframe\n     * as default.\n     */\n    keyframes = [0],\n    velocity = 0,\n    power = 0.8,\n    timeConstant = 350,\n    restDelta = 0.5,\n    modifyTarget\n  } = _ref;\n  const origin = keyframes[0];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n  const state = {\n    done: false,\n    value: origin\n  };\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n  if (target !== ideal) amplitude = target - origin;\n  return {\n    next: t => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {}\n  };\n}\nexport { decay };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}