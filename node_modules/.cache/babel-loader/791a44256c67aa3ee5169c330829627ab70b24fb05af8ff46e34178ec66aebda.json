{"ast":null,"code":"import * as t from \"react\";\nfunction n() {\n  return n = Object.assign || function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var e = arguments[n];\n      for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);\n    }\n    return t;\n  }, n.apply(this, arguments);\n}\nconst e = [\"children\", \"options\"],\n  r = [\"allowFullScreen\", \"allowTransparency\", \"autoComplete\", \"autoFocus\", \"autoPlay\", \"cellPadding\", \"cellSpacing\", \"charSet\", \"className\", \"classId\", \"colSpan\", \"contentEditable\", \"contextMenu\", \"crossOrigin\", \"encType\", \"formAction\", \"formEncType\", \"formMethod\", \"formNoValidate\", \"formTarget\", \"frameBorder\", \"hrefLang\", \"inputMode\", \"keyParams\", \"keyType\", \"marginHeight\", \"marginWidth\", \"maxLength\", \"mediaGroup\", \"minLength\", \"noValidate\", \"radioGroup\", \"readOnly\", \"rowSpan\", \"spellCheck\", \"srcDoc\", \"srcLang\", \"srcSet\", \"tabIndex\", \"useMap\"].reduce((t, n) => (t[n.toLowerCase()] = n, t), {\n    for: \"htmlFor\"\n  }),\n  o = {\n    amp: \"&\",\n    apos: \"'\",\n    gt: \">\",\n    lt: \"<\",\n    nbsp: \" \",\n    quot: \"“\"\n  },\n  c = [\"style\", \"script\"],\n  a = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi,\n  _ = /mailto:/i,\n  u = /\\n{2,}$/,\n  i = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/,\n  l = /^ *> ?/gm,\n  s = /^ {2,}\\n/,\n  f = /^(?:( *[-*_])){3,} *(?:\\n *)+\\n/,\n  d = /^\\s*(`{3,}|~{3,}) *(\\S+)?([^\\n]*?)?\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)*\\n?/,\n  p = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/,\n  m = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  g = /^(?:\\n *)*\\n/,\n  y = /\\r\\n?/g,\n  h = /^\\[\\^([^\\]]+)](:.*)\\n/,\n  k = /^\\[\\^([^\\]]+)]/,\n  x = /\\f/g,\n  b = /^\\s*?\\[(x|\\s)\\]/,\n  v = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n  $ = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/,\n  S = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i,\n  z = /&([a-zA-Z]+);/g,\n  w = /^<!--[\\s\\S]*?(?:-->)/,\n  A = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/,\n  E = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i,\n  L = /^\\{.*\\}$/,\n  M = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  I = /^<([^ >]+@[^ >]+)>/,\n  O = /^<([^ >]+:\\/[^ >]+)>/,\n  B = /-([a-z])?/gi,\n  R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/,\n  T = /^\\[([^\\]]*)\\]:\\s+<?([^\\s>]+)>?\\s*(\"([^\"]*)\")?/,\n  j = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  C = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n  D = /(\\[|\\])/g,\n  N = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/,\n  Z = /\\t/g,\n  F = /^ *\\| */,\n  P = /(^ *\\||\\| *$)/g,\n  G = / *$/,\n  H = /^ *:-+: *$/,\n  q = /^ *:-+ *$/,\n  U = /^ *-+: *$/,\n  V = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/,\n  W = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/,\n  Q = /^==((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)==/,\n  X = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/,\n  J = /^\\\\([^0-9A-Za-z\\s])/,\n  K = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i,\n  Y = /^\\n+/,\n  tt = /^([ \\t]*)/,\n  nt = /\\\\([^\\\\])/g,\n  et = / *\\n+$/,\n  rt = /(?:^|\\n)( *)$/,\n  ot = \"(?:\\\\d+\\\\.)\",\n  ct = \"(?:[*+-])\";\nfunction at(t) {\n  return \"( *)(\" + (1 === t ? ot : ct) + \") +\";\n}\nconst _t = at(1),\n  ut = at(2);\nfunction it(t) {\n  return new RegExp(\"^\" + (1 === t ? _t : ut));\n}\nconst lt = it(1),\n  st = it(2);\nfunction ft(t) {\n  return new RegExp(\"^\" + (1 === t ? _t : ut) + \"[^\\\\n]*(?:\\\\n(?!\\\\1\" + (1 === t ? ot : ct) + \" )[^\\\\n]*)*(\\\\n|$)\", \"gm\");\n}\nconst dt = ft(1),\n  pt = ft(2);\nfunction mt(t) {\n  const n = 1 === t ? ot : ct;\n  return new RegExp(\"^( *)(\" + n + \") [\\\\s\\\\S]+?(?:\\\\n{2,}(?! )(?!\\\\1\" + n + \" (?!\" + n + \" ))\\\\n*|\\\\s*\\\\n*$)\");\n}\nconst gt = mt(1),\n  yt = mt(2);\nfunction ht(t, n) {\n  const e = 1 === n,\n    r = e ? gt : yt,\n    o = e ? dt : pt,\n    c = e ? lt : st;\n  return {\n    t(t, n, e) {\n      const o = rt.exec(e);\n      return o && (n.o || !n._ && !n.u) ? r.exec(t = o[1] + t) : null;\n    },\n    i: Gt.HIGH,\n    l(t, n, r) {\n      const a = e ? +t[2] : void 0,\n        _ = t[0].replace(u, \"\\n\").match(o);\n      let i = !1;\n      return {\n        p: _.map(function (t, e) {\n          const o = c.exec(t)[0].length,\n            a = new RegExp(\"^ {1,\" + o + \"}\", \"gm\"),\n            u = t.replace(a, \"\").replace(c, \"\"),\n            l = e === _.length - 1,\n            s = -1 !== u.indexOf(\"\\n\\n\") || l && i;\n          i = s;\n          const f = r._,\n            d = r.o;\n          let p;\n          r.o = !0, s ? (r._ = !1, p = u.replace(et, \"\\n\\n\")) : (r._ = !0, p = u.replace(et, \"\"));\n          const m = n(p, r);\n          return r._ = f, r.o = d, m;\n        }),\n        m: e,\n        g: a\n      };\n    },\n    h: (n, e, r) => t(n.m ? \"ol\" : \"ul\", {\n      key: r.k,\n      start: n.g\n    }, n.p.map(function (n, o) {\n      return t(\"li\", {\n        key: o\n      }, e(n, r));\n    }))\n  };\n}\nconst kt = /^\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n  xt = /^!\\[([^\\]]*)]\\( *((?:\\([^)]*\\)|[^() ])*) *\"?([^)\"]*)?\"?\\)/,\n  bt = [i, d, p, v, $, w, R, dt, gt, pt, yt],\n  vt = [...bt, /^[^\\n]+(?:  \\n|\\n{2,})/, S, E];\nfunction $t(t) {\n  return t.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, \"a\").replace(/[çÇ]/g, \"c\").replace(/[ðÐ]/g, \"d\").replace(/[ÈÉÊËéèêë]/g, \"e\").replace(/[ÏïÎîÍíÌì]/g, \"i\").replace(/[Ññ]/g, \"n\").replace(/[øØœŒÕõÔôÓóÒò]/g, \"o\").replace(/[ÜüÛûÚúÙù]/g, \"u\").replace(/[ŸÿÝý]/g, \"y\").replace(/[^a-z0-9- ]/gi, \"\").replace(/ /gi, \"-\").toLowerCase();\n}\nfunction St(t) {\n  return U.test(t) ? \"right\" : H.test(t) ? \"center\" : q.test(t) ? \"left\" : null;\n}\nfunction zt(t, n, e) {\n  const r = e.v;\n  e.v = !0;\n  const o = n(t.trim(), e);\n  e.v = r;\n  let c = [[]];\n  return o.forEach(function (t, n) {\n    \"tableSeparator\" === t.type ? 0 !== n && n !== o.length - 1 && c.push([]) : (\"text\" !== t.type || null != o[n + 1] && \"tableSeparator\" !== o[n + 1].type || (t.$ = t.$.replace(G, \"\")), c[c.length - 1].push(t));\n  }), c;\n}\nfunction wt(t, n, e) {\n  e._ = !0;\n  const r = zt(t[1], n, e),\n    o = t[2].replace(P, \"\").split(\"|\").map(St),\n    c = function (t, n, e) {\n      return t.trim().split(\"\\n\").map(function (t) {\n        return zt(t, n, e);\n      });\n    }(t[3], n, e);\n  return e._ = !1, {\n    S: o,\n    A: c,\n    L: r,\n    type: \"table\"\n  };\n}\nfunction At(t, n) {\n  return null == t.S[n] ? {} : {\n    textAlign: t.S[n]\n  };\n}\nfunction Et(t) {\n  return function (n, e) {\n    return e._ ? t.exec(n) : null;\n  };\n}\nfunction Lt(t) {\n  return function (n, e) {\n    return e._ || e.u ? t.exec(n) : null;\n  };\n}\nfunction Mt(t) {\n  return function (n, e) {\n    return e._ || e.u ? null : t.exec(n);\n  };\n}\nfunction It(t) {\n  return function (n) {\n    return t.exec(n);\n  };\n}\nfunction Ot(t, n, e) {\n  if (n._ || n.u) return null;\n  if (e && !e.endsWith(\"\\n\")) return null;\n  let r = \"\";\n  t.split(\"\\n\").every(t => !bt.some(n => n.test(t)) && (r += t + \"\\n\", t.trim()));\n  const o = r.trimEnd();\n  return \"\" == o ? null : [r, o];\n}\nfunction Bt(t) {\n  try {\n    if (decodeURIComponent(t).replace(/[^A-Za-z0-9/:]/g, \"\").match(/^\\s*(javascript|vbscript|data(?!:image)):/i)) return null;\n  } catch (t) {\n    return null;\n  }\n  return t;\n}\nfunction Rt(t) {\n  return t.replace(nt, \"$1\");\n}\nfunction Tt(t, n, e) {\n  const r = e._ || !1,\n    o = e.u || !1;\n  e._ = !0, e.u = !0;\n  const c = t(n, e);\n  return e._ = r, e.u = o, c;\n}\nfunction jt(t, n, e) {\n  const r = e._ || !1,\n    o = e.u || !1;\n  e._ = !1, e.u = !0;\n  const c = t(n, e);\n  return e._ = r, e.u = o, c;\n}\nfunction Ct(t, n, e) {\n  return e._ = !1, t(n + \"\\n\\n\", e);\n}\nconst Dt = (t, n, e) => ({\n  $: Tt(n, t[1], e)\n});\nfunction Nt() {\n  return {};\n}\nfunction Zt() {\n  return null;\n}\nfunction Ft() {\n  for (var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++) {\n    t[_key] = arguments[_key];\n  }\n  return t.filter(Boolean).join(\" \");\n}\nfunction Pt(t, n, e) {\n  let r = t;\n  const o = n.split(\".\");\n  for (; o.length && (r = r[o[0]], void 0 !== r);) o.shift();\n  return r || e;\n}\nvar Gt;\nfunction Ht(e) {\n  let u = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  u.overrides = u.overrides || {}, u.slugify = u.slugify || $t, u.namedCodesToUnicode = u.namedCodesToUnicode ? n({}, o, u.namedCodesToUnicode) : o;\n  const P = u.createElement || t.createElement;\n  function G(t, e) {\n    const o = Pt(u.overrides, `${t}.props`, {});\n    for (var _len2 = arguments.length, r = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      r[_key2 - 2] = arguments[_key2];\n    }\n    return P(function (t, n) {\n      const e = Pt(n, t);\n      return e ? \"function\" == typeof e || \"object\" == typeof e && \"render\" in e ? e : Pt(n, `${t}.component`, t) : t;\n    }(t, u.overrides), n({}, e, o, {\n      className: Ft(null == e ? void 0 : e.className, o.className) || void 0\n    }), ...r);\n  }\n  function H(n) {\n    let e = !1;\n    u.forceInline ? e = !0 : u.forceBlock || (e = !1 === N.test(n));\n    const r = ot(rt(e ? n : `${n.trimEnd().replace(Y, \"\")}\\n\\n`, {\n      _: e\n    }));\n    for (; \"string\" == typeof r[r.length - 1] && !r[r.length - 1].trim();) r.pop();\n    if (null === u.wrapper) return r;\n    const o = u.wrapper || (e ? \"span\" : \"div\");\n    let c;\n    if (r.length > 1 || u.forceWrapper) c = r;else {\n      if (1 === r.length) return c = r[0], \"string\" == typeof c ? G(\"span\", {\n        key: \"outer\"\n      }, c) : c;\n      c = null;\n    }\n    return t.createElement(o, {\n      key: \"outer\"\n    }, c);\n  }\n  function q(n) {\n    const e = n.match(a);\n    return e ? e.reduce(function (n, e, o) {\n      const c = e.indexOf(\"=\");\n      if (-1 !== c) {\n        const a = function (t) {\n            return -1 !== t.indexOf(\"-\") && null === t.match(A) && (t = t.replace(B, function (t, n) {\n              return n.toUpperCase();\n            })), t;\n          }(e.slice(0, c)).trim(),\n          _ = function (t) {\n            const n = t[0];\n            return ('\"' === n || \"'\" === n) && t.length >= 2 && t[t.length - 1] === n ? t.slice(1, -1) : t;\n          }(e.slice(c + 1).trim()),\n          u = r[a] || a,\n          i = n[u] = function (t, n) {\n            return \"style\" === t ? n.split(/;\\s?/).reduce(function (t, n) {\n              const e = n.slice(0, n.indexOf(\":\"));\n              return t[e.replace(/(-[a-z])/g, t => t[1].toUpperCase())] = n.slice(e.length + 1).trim(), t;\n            }, {}) : \"href\" === t ? Bt(n) : (n.match(L) && (n = n.slice(1, n.length - 1)), \"true\" === n || \"false\" !== n && n);\n          }(a, _);\n        \"string\" == typeof i && (S.test(i) || E.test(i)) && (n[u] = t.cloneElement(H(i.trim()), {\n          key: o\n        }));\n      } else \"style\" !== e && (n[r[e] || e] = !0);\n      return n;\n    }, {}) : null;\n  }\n  const U = [],\n    nt = {},\n    et = {\n      blockQuote: {\n        t: Mt(i),\n        i: Gt.HIGH,\n        l: (t, n, e) => ({\n          $: n(t[0].replace(l, \"\"), e)\n        }),\n        h: (t, n, e) => G(\"blockquote\", {\n          key: e.k\n        }, n(t.$, e))\n      },\n      breakLine: {\n        t: It(s),\n        i: Gt.HIGH,\n        l: Nt,\n        h: (t, n, e) => G(\"br\", {\n          key: e.k\n        })\n      },\n      breakThematic: {\n        t: Mt(f),\n        i: Gt.HIGH,\n        l: Nt,\n        h: (t, n, e) => G(\"hr\", {\n          key: e.k\n        })\n      },\n      codeBlock: {\n        t: Mt(p),\n        i: Gt.MAX,\n        l: t => ({\n          $: t[0].replace(/^ {4}/gm, \"\").replace(/\\n+$/, \"\"),\n          M: void 0\n        }),\n        h: (t, e, r) => G(\"pre\", {\n          key: r.k\n        }, G(\"code\", n({}, t.I, {\n          className: t.M ? `lang-${t.M}` : \"\"\n        }), t.$))\n      },\n      codeFenced: {\n        t: Mt(d),\n        i: Gt.MAX,\n        l: t => ({\n          I: q(t[3] || \"\"),\n          $: t[4],\n          M: t[2] || void 0,\n          type: \"codeBlock\"\n        })\n      },\n      codeInline: {\n        t: Lt(m),\n        i: Gt.LOW,\n        l: t => ({\n          $: t[2]\n        }),\n        h: (t, n, e) => G(\"code\", {\n          key: e.k\n        }, t.$)\n      },\n      footnote: {\n        t: Mt(h),\n        i: Gt.MAX,\n        l: t => (U.push({\n          O: t[2],\n          B: t[1]\n        }), {}),\n        h: Zt\n      },\n      footnoteReference: {\n        t: Et(k),\n        i: Gt.HIGH,\n        l: t => ({\n          $: t[1],\n          R: `#${u.slugify(t[1])}`\n        }),\n        h: (t, n, e) => G(\"a\", {\n          key: e.k,\n          href: Bt(t.R)\n        }, G(\"sup\", {\n          key: e.k\n        }, t.$))\n      },\n      gfmTask: {\n        t: Et(b),\n        i: Gt.HIGH,\n        l: t => ({\n          T: \"x\" === t[1].toLowerCase()\n        }),\n        h: (t, n, e) => G(\"input\", {\n          checked: t.T,\n          key: e.k,\n          readOnly: !0,\n          type: \"checkbox\"\n        })\n      },\n      heading: {\n        t: Mt(v),\n        i: Gt.HIGH,\n        l: (t, n, e) => ({\n          $: Tt(n, t[2], e),\n          j: u.slugify(t[2]),\n          C: t[1].length\n        }),\n        h: (t, n, e) => G(`h${t.C}`, {\n          id: t.j,\n          key: e.k\n        }, n(t.$, e))\n      },\n      headingSetext: {\n        t: Mt($),\n        i: Gt.MAX,\n        l: (t, n, e) => ({\n          $: Tt(n, t[1], e),\n          C: \"=\" === t[2] ? 1 : 2,\n          type: \"heading\"\n        })\n      },\n      htmlComment: {\n        t: It(w),\n        i: Gt.HIGH,\n        l: () => ({}),\n        h: Zt\n      },\n      image: {\n        t: Lt(xt),\n        i: Gt.HIGH,\n        l: t => ({\n          D: t[1],\n          R: Rt(t[2]),\n          N: t[3]\n        }),\n        h: (t, n, e) => G(\"img\", {\n          key: e.k,\n          alt: t.D || void 0,\n          title: t.N || void 0,\n          src: Bt(t.R)\n        })\n      },\n      link: {\n        t: Et(kt),\n        i: Gt.LOW,\n        l: (t, n, e) => ({\n          $: jt(n, t[1], e),\n          R: Rt(t[2]),\n          N: t[3]\n        }),\n        h: (t, n, e) => G(\"a\", {\n          key: e.k,\n          href: Bt(t.R),\n          title: t.N\n        }, n(t.$, e))\n      },\n      linkAngleBraceStyleDetector: {\n        t: Et(O),\n        i: Gt.MAX,\n        l: t => ({\n          $: [{\n            $: t[1],\n            type: \"text\"\n          }],\n          R: t[1],\n          type: \"link\"\n        })\n      },\n      linkBareUrlDetector: {\n        t: (t, n) => n.Z ? null : Et(M)(t, n),\n        i: Gt.MAX,\n        l: t => ({\n          $: [{\n            $: t[1],\n            type: \"text\"\n          }],\n          R: t[1],\n          N: void 0,\n          type: \"link\"\n        })\n      },\n      linkMailtoDetector: {\n        t: Et(I),\n        i: Gt.MAX,\n        l(t) {\n          let n = t[1],\n            e = t[1];\n          return _.test(e) || (e = \"mailto:\" + e), {\n            $: [{\n              $: n.replace(\"mailto:\", \"\"),\n              type: \"text\"\n            }],\n            R: e,\n            type: \"link\"\n          };\n        }\n      },\n      orderedList: ht(G, 1),\n      unorderedList: ht(G, 2),\n      newlineCoalescer: {\n        t: Mt(g),\n        i: Gt.LOW,\n        l: Nt,\n        h: () => \"\\n\"\n      },\n      paragraph: {\n        t: Ot,\n        i: Gt.LOW,\n        l: Dt,\n        h: (t, n, e) => G(\"p\", {\n          key: e.k\n        }, n(t.$, e))\n      },\n      ref: {\n        t: Et(T),\n        i: Gt.MAX,\n        l: t => (nt[t[1]] = {\n          R: t[2],\n          N: t[4]\n        }, {}),\n        h: Zt\n      },\n      refImage: {\n        t: Lt(j),\n        i: Gt.MAX,\n        l: t => ({\n          D: t[1] || void 0,\n          F: t[2]\n        }),\n        h: (t, n, e) => G(\"img\", {\n          key: e.k,\n          alt: t.D,\n          src: Bt(nt[t.F].R),\n          title: nt[t.F].N\n        })\n      },\n      refLink: {\n        t: Et(C),\n        i: Gt.MAX,\n        l: (t, n, e) => ({\n          $: n(t[1], e),\n          P: n(t[0].replace(D, \"\\\\$1\"), e),\n          F: t[2]\n        }),\n        h: (t, n, e) => nt[t.F] ? G(\"a\", {\n          key: e.k,\n          href: Bt(nt[t.F].R),\n          title: nt[t.F].N\n        }, n(t.$, e)) : G(\"span\", {\n          key: e.k\n        }, n(t.P, e))\n      },\n      table: {\n        t: Mt(R),\n        i: Gt.HIGH,\n        l: wt,\n        h: (t, n, e) => G(\"table\", {\n          key: e.k\n        }, G(\"thead\", null, G(\"tr\", null, t.L.map(function (r, o) {\n          return G(\"th\", {\n            key: o,\n            style: At(t, o)\n          }, n(r, e));\n        }))), G(\"tbody\", null, t.A.map(function (r, o) {\n          return G(\"tr\", {\n            key: o\n          }, r.map(function (r, o) {\n            return G(\"td\", {\n              key: o,\n              style: At(t, o)\n            }, n(r, e));\n          }));\n        })))\n      },\n      tableSeparator: {\n        t: function (t, n) {\n          return n.v ? F.exec(t) : null;\n        },\n        i: Gt.HIGH,\n        l: function () {\n          return {\n            type: \"tableSeparator\"\n          };\n        },\n        h: () => \" | \"\n      },\n      text: {\n        t: It(K),\n        i: Gt.MIN,\n        l: t => ({\n          $: t[0].replace(z, (t, n) => u.namedCodesToUnicode[n] ? u.namedCodesToUnicode[n] : t)\n        }),\n        h: t => t.$\n      },\n      textBolded: {\n        t: Lt(V),\n        i: Gt.MED,\n        l: (t, n, e) => ({\n          $: n(t[2], e)\n        }),\n        h: (t, n, e) => G(\"strong\", {\n          key: e.k\n        }, n(t.$, e))\n      },\n      textEmphasized: {\n        t: Lt(W),\n        i: Gt.LOW,\n        l: (t, n, e) => ({\n          $: n(t[2], e)\n        }),\n        h: (t, n, e) => G(\"em\", {\n          key: e.k\n        }, n(t.$, e))\n      },\n      textEscaped: {\n        t: Lt(J),\n        i: Gt.HIGH,\n        l: t => ({\n          $: t[1],\n          type: \"text\"\n        })\n      },\n      textMarked: {\n        t: Lt(Q),\n        i: Gt.LOW,\n        l: Dt,\n        h: (t, n, e) => G(\"mark\", {\n          key: e.k\n        }, n(t.$, e))\n      },\n      textStrikethroughed: {\n        t: Lt(X),\n        i: Gt.LOW,\n        l: Dt,\n        h: (t, n, e) => G(\"del\", {\n          key: e.k\n        }, n(t.$, e))\n      }\n    };\n  !0 !== u.disableParsingRawHTML && (et.htmlBlock = {\n    t: It(S),\n    i: Gt.HIGH,\n    l(t, n, e) {\n      const [, r] = t[3].match(tt),\n        o = new RegExp(`^${r}`, \"gm\"),\n        a = t[3].replace(o, \"\"),\n        _ = (u = a, vt.some(t => t.test(u)) ? Ct : Tt);\n      var u;\n      const i = t[1].toLowerCase(),\n        l = -1 !== c.indexOf(i);\n      e.Z = e.Z || \"a\" === i;\n      const s = l ? t[3] : _(n, a, e);\n      return e.Z = !1, {\n        I: q(t[2]),\n        $: s,\n        G: l,\n        H: l ? i : t[1]\n      };\n    },\n    h: (t, e, r) => G(t.H, n({\n      key: r.k\n    }, t.I), t.G ? t.$ : e(t.$, r))\n  }, et.htmlSelfClosing = {\n    t: It(E),\n    i: Gt.HIGH,\n    l: t => ({\n      I: q(t[2] || \"\"),\n      H: t[1]\n    }),\n    h: (t, e, r) => G(t.H, n({}, t.I, {\n      key: r.k\n    }))\n  });\n  const rt = function (t) {\n      let n = Object.keys(t);\n      function e(r, o) {\n        let c = [],\n          a = \"\";\n        for (; r;) {\n          let _ = 0;\n          for (; _ < n.length;) {\n            const u = n[_],\n              i = t[u],\n              l = i.t(r, o, a);\n            if (l) {\n              const t = l[0];\n              r = r.substring(t.length);\n              const n = i.l(l, e, o);\n              null == n.type && (n.type = u), c.push(n), a = t;\n              break;\n            }\n            _++;\n          }\n        }\n        return c;\n      }\n      return n.sort(function (n, e) {\n        let r = t[n].i,\n          o = t[e].i;\n        return r !== o ? r - o : n < e ? -1 : 1;\n      }), function (t, n) {\n        return e(function (t) {\n          return t.replace(y, \"\\n\").replace(x, \"\").replace(Z, \"    \");\n        }(t), n);\n      };\n    }(et),\n    ot = (ct = function (t) {\n      return function (n, e, r) {\n        return t[n.type].h(n, e, r);\n      };\n    }(et), function t(n) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (Array.isArray(n)) {\n        const r = e.k,\n          o = [];\n        let c = !1;\n        for (let r = 0; r < n.length; r++) {\n          e.k = r;\n          const a = t(n[r], e),\n            _ = \"string\" == typeof a;\n          _ && c ? o[o.length - 1] += a : null !== a && o.push(a), c = _;\n        }\n        return e.k = r, o;\n      }\n      return ct(n, t, e);\n    });\n  var ct;\n  const at = H(e);\n  return U.length ? G(\"div\", null, at, G(\"footer\", {\n    key: \"footer\"\n  }, U.map(function (t) {\n    return G(\"div\", {\n      id: u.slugify(t.B),\n      key: t.B\n    }, t.B, ot(rt(t.O, {\n      _: !0\n    })));\n  }))) : at;\n}\n!function (t) {\n  t[t.MAX = 0] = \"MAX\", t[t.HIGH = 1] = \"HIGH\", t[t.MED = 2] = \"MED\", t[t.LOW = 3] = \"LOW\", t[t.MIN = 4] = \"MIN\";\n}(Gt || (Gt = {}));\nexport default (n => {\n  let {\n      children: r,\n      options: o\n    } = n,\n    c = function (t, n) {\n      if (null == t) return {};\n      var e,\n        r,\n        o = {},\n        c = Object.keys(t);\n      for (r = 0; r < c.length; r++) n.indexOf(e = c[r]) >= 0 || (o[e] = t[e]);\n      return o;\n    }(n, e);\n  return t.cloneElement(Ht(r, o), c);\n});\nexport { Ht as compiler };\n//# sourceMappingURL=index.modern.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}