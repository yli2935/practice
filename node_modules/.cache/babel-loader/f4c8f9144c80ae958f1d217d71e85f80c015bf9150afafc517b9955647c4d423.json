{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\nconst colorToken = \"${c}\";\nconst numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b;\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nfunction analyseComplexValue(v) {\n  if (typeof v === \"number\") v = `${v}`;\n  const values = [];\n  let numColors = 0;\n  let numNumbers = 0;\n  const colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    // Strip colors from input so they're not picked up by number regex.\n    // There's a better way to combine these regex searches, but its beyond my regex skills\n    v = v.replace(colorRegex, colorToken);\n    values.push(...colors.map(color.parse));\n  }\n  const numbers = v.match(floatRegex);\n  if (numbers) {\n    numNumbers = numbers.length;\n    v = v.replace(floatRegex, numberToken);\n    values.push(...numbers.map(number.parse));\n  }\n  return {\n    values,\n    numColors,\n    numNumbers,\n    tokenised: v\n  };\n}\nfunction parse(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  const {\n    values,\n    numColors,\n    tokenised\n  } = analyseComplexValue(source);\n  const numValues = values.length;\n  return v => {\n    let output = tokenised;\n    for (let i = 0; i < numValues; i++) {\n      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\n    }\n    return output;\n  };\n}\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n  const parsed = parse(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n  test,\n  parse,\n  createTransformer,\n  getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}