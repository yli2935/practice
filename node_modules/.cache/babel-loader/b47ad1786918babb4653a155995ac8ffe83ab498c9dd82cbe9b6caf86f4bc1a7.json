{"ast":null,"code":"import { sync } from '../../frameloop/index.mjs';\nimport { transformProps } from '../../render/html/utils/transform.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(id, name) {\n  const {\n    MotionAppearAnimations\n  } = window;\n  const animationId = appearStoreId(id, transformProps.has(name) ? \"transform\" : name);\n  const animation = MotionAppearAnimations && MotionAppearAnimations.get(animationId);\n  if (animation) {\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n    sync.render(() => {\n      /**\n       * Animation.cancel() throws so it needs to be wrapped in a try/catch\n       */\n      try {\n        animation.cancel();\n        MotionAppearAnimations.delete(animationId);\n      } catch (e) {}\n    });\n    return animation.currentTime || 0;\n  } else {\n    return 0;\n  }\n}\nexport { handoffOptimizedAppearAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}