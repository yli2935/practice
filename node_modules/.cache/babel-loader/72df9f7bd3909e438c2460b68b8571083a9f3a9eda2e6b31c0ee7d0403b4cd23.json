{"ast":null,"code":"'use strict';\n\nvar high = require('highlight.js/lib/core');\nvar fault = require('fault');\nexports.highlight = highlight;\nexports.highlightAuto = highlightAuto;\nexports.registerLanguage = registerLanguage;\nexports.listLanguages = listLanguages;\nexports.registerAlias = registerAlias;\nEmitter.prototype.addText = text;\nEmitter.prototype.addKeyword = addKeyword;\nEmitter.prototype.addSublanguage = addSublanguage;\nEmitter.prototype.openNode = open;\nEmitter.prototype.closeNode = close;\nEmitter.prototype.closeAllNodes = noop;\nEmitter.prototype.finalize = noop;\nEmitter.prototype.toHTML = toHtmlNoop;\nvar defaultPrefix = 'hljs-';\n\n// Highlighting `value` in the language `name`.\nfunction highlight(name, value, options) {\n  var before = high.configure({});\n  var settings = options || {};\n  var prefix = settings.prefix;\n  var result;\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name);\n  }\n  if (!high.getLanguage(name)) {\n    throw fault('Unknown language: `%s` is not registered', name);\n  }\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n  high.configure({\n    __emitter: Emitter,\n    classPrefix: prefix\n  });\n  result = high.highlight(value, {\n    language: name,\n    ignoreIllegals: true\n  });\n  high.configure(before || {});\n\n  /* istanbul ignore if - Highlight.js seems to use this (currently) for broken\n   * grammars, so letâ€™s keep it in there just to be sure. */\n  if (result.errorRaised) {\n    throw result.errorRaised;\n  }\n  return {\n    relevance: result.relevance,\n    language: result.language,\n    value: result.emitter.rootNode.children\n  };\n}\nfunction highlightAuto(value, options) {\n  var settings = options || {};\n  var subset = settings.subset || high.listLanguages();\n  var prefix = settings.prefix;\n  var length = subset.length;\n  var index = -1;\n  var result;\n  var secondBest;\n  var current;\n  var name;\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n  secondBest = {\n    relevance: 0,\n    language: null,\n    value: []\n  };\n  result = {\n    relevance: 0,\n    language: null,\n    value: []\n  };\n  while (++index < length) {\n    name = subset[index];\n    if (!high.getLanguage(name)) {\n      continue;\n    }\n    current = highlight(name, value, options);\n    current.language = name;\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current;\n    }\n    if (current.relevance > result.relevance) {\n      secondBest = result;\n      result = current;\n    }\n  }\n  if (secondBest.language) {\n    result.secondBest = secondBest;\n  }\n  return result;\n}\n\n// Register a language.\nfunction registerLanguage(name, syntax) {\n  high.registerLanguage(name, syntax);\n}\n\n// Get a list of all registered languages.\nfunction listLanguages() {\n  return high.listLanguages();\n}\n\n// Register more aliases for an already registered language.\nfunction registerAlias(name, alias) {\n  var map = name;\n  var key;\n  if (alias) {\n    map = {};\n    map[name] = alias;\n  }\n  for (key in map) {\n    high.registerAliases(map[key], {\n      languageName: key\n    });\n  }\n}\nfunction Emitter(options) {\n  this.options = options;\n  this.rootNode = {\n    children: []\n  };\n  this.stack = [this.rootNode];\n}\nfunction addKeyword(value, name) {\n  this.openNode(name);\n  this.addText(value);\n  this.closeNode();\n}\nfunction addSublanguage(other, name) {\n  var stack = this.stack;\n  var current = stack[stack.length - 1];\n  var results = other.rootNode.children;\n  var node = name ? {\n    type: 'element',\n    tagName: 'span',\n    properties: {\n      className: [name]\n    },\n    children: results\n  } : results;\n  current.children = current.children.concat(node);\n}\nfunction text(value) {\n  var stack = this.stack;\n  var current;\n  var tail;\n  if (value === '') return;\n  current = stack[stack.length - 1];\n  tail = current.children[current.children.length - 1];\n  if (tail && tail.type === 'text') {\n    tail.value += value;\n  } else {\n    current.children.push({\n      type: 'text',\n      value: value\n    });\n  }\n}\nfunction open(name) {\n  var stack = this.stack;\n  var className = this.options.classPrefix + name;\n  var current = stack[stack.length - 1];\n  var child = {\n    type: 'element',\n    tagName: 'span',\n    properties: {\n      className: [className]\n    },\n    children: []\n  };\n  current.children.push(child);\n  stack.push(child);\n}\nfunction close() {\n  this.stack.pop();\n}\nfunction toHtmlNoop() {\n  return '';\n}\nfunction noop() {}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}